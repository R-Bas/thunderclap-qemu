#ifndef MACOS_MM_HIGH_SIERRA_H
#define MACOS_MM_HIGH_SIERRA_H

#include <stdint.h>
#include "freebsd-queue.h"

typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef int kern_return_t;
typedef unsigned int u_int;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;
typedef uint64_t MM_caddr_t; /* Actual definition is char * */
typedef uint64_t MM_struct_mbuf_p;

/* header at beginning of each mbuf: */
struct m_hdr {
	MM_struct_mbuf_p mh_next;	/* next buffer in chain */
	MM_struct_mbuf_p mh_nextpkt;	/* next chain in queue/record */
	MM_caddr_t		mh_data;	/* location of data */
	int32_t		mh_len;		/* amount of data in this mbuf */
	u_int16_t	mh_type;	/* type of data in this mbuf */
	u_int16_t	mh_flags;	/* flags; see below */
};

/*
 * Packet tag structure (see below for details).
 */
struct m_tag {
	u_int64_t		m_tag_cookie;	/* Error checking */
#ifndef __LP64__
	u_int32_t		pad;		/* For structure alignment */
#endif /* !__LP64__ */
	SLIST_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
	u_int16_t		m_tag_type;	/* Module specific type */
	u_int16_t		m_tag_len;	/* Length of data */
	u_int32_t		m_tag_id;	/* Module ID */
};

#define	M_TAG_ALIGN(len) \
	(P2ROUNDUP(len, sizeof (u_int64_t)) + sizeof (struct m_tag))

#define	M_TAG_VALID_PATTERN	0xfeedfacefeedfaceULL
#define	M_TAG_FREE_PATTERN	0xdeadbeefdeadbeefULL

/*
 * Packet tag header structure (at the top of mbuf).  Pointers are
 * 32-bit in ILP32; m_tag needs 64-bit alignment, hence padded.
 */
struct m_taghdr {
#ifndef __LP64__
	u_int32_t		pad;		/* For structure alignment */
#endif /* !__LP64__ */
	u_int64_t		refcnt;		/* Number of tags in this mbuf */
};

/*
 * Driver auxiliary metadata tag (KERNEL_TAG_TYPE_DRVAUX).
 */
struct m_drvaux_tag {
	u_int32_t	da_family;	/* IFNET_FAMILY values */
	u_int32_t	da_subfamily;	/* IFNET_SUBFAMILY values */
	u_int32_t	da_reserved;	/* for future */
	u_int32_t	da_length;	/* length of following data */
};

/* Values for pftag_flags (16-bit wide) */
#define	PF_TAG_GENERATED		0x1	/* pkt generated by PF */
#define	PF_TAG_FRAGCACHE		0x2
#define	PF_TAG_TRANSLATE_LOCALHOST	0x4
#if PF_ECN
#define	PF_TAG_HDR_INET			0x8	/* hdr points to IPv4 */
#define	PF_TAG_HDR_INET6		0x10	/* hdr points to IPv6 */
#endif /* PF_ECN */
/*
 * PF mbuf tag
 */
struct pf_mtag {
	u_int16_t	pftag_flags;	/* PF_TAG flags */
	u_int16_t	pftag_rtableid;	/* alternate routing table id */
	u_int16_t	pftag_tag;
	u_int16_t	pftag_routed;
#if PF_ECN
	void		*pftag_hdr;	/* saved hdr pos in mbuf, for ECN */
#endif /* PF_ECN */
};

/*
 * TCP mbuf tag
 */
struct tcp_pktinfo {
	union {
		struct {
			u_int32_t segsz;	/* segment size (actual MSS) */
			u_int32_t start_seq;	/* start seq of this packet */
		} __tx;
		struct {
			u_int16_t lro_pktlen;	/* max seg size encountered */
			u_int8_t  lro_npkts;	/* # of coalesced TCP pkts */
			u_int8_t  lro_timediff;	/* time spent in LRO */
		} __rx;
	} __offload;
	union {
		u_int32_t	pri;		/* send msg priority */
		u_int32_t	seq;		/* recv msg sequence # */
	} __msgattr;
#define tso_segsz	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.segsz
#define	tx_start_seq	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.start_seq
#define lro_pktlen	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_pktlen
#define lro_npkts	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_npkts
#define lro_elapsed	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_timediff
#define msg_pri		proto_mtag.__pr_u.tcp.tm_tcp.__msgattr.pri
#define msg_seq		proto_mtag.__pr_u.tcp.tm_tcp.__msgattr.seq
};

/*
 * MPTCP mbuf tag
 */
struct mptcp_pktinfo {
	u_int64_t	mtpi_dsn;	/* MPTCP Data Sequence Number */
	u_int32_t	mtpi_rel_seq;	/* Relative Seq Number */
	u_int16_t	mtpi_length;	/* Length of mapping */
	u_int16_t	mtpi_csum;
#define	mp_dsn		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_dsn
#define	mp_rseq		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_rel_seq
#define	mp_rlen		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_length
#define	mp_csum		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_csum
};

/*
 * TCP specific mbuf tag.  Note that the current implementation uses
 * MPTCP metadata strictly between MPTCP and the TCP subflow layers,
 * hence tm_tcp and tm_mptcp are mutually exclusive.  This also means
 * that TCP messages functionality is currently incompatible with MPTCP.
 */
struct tcp_mtag {
	union {
		struct tcp_pktinfo	tm_tcp;		/* TCP and below */
		struct mptcp_pktinfo	tm_mptcp;	/* MPTCP-TCP only */
	};
};

struct driver_mtag_ {
	uintptr_t		_drv_tx_compl_arg;
	uintptr_t		_drv_tx_compl_data;
	kern_return_t		_drv_tx_status;
	uint16_t		_drv_flowid;
#define drv_tx_compl_arg	builtin_mtag._drv_mtag._drv_tx_compl_arg
#define drv_tx_compl_data	builtin_mtag._drv_mtag._drv_tx_compl_data
#define drv_tx_status		builtin_mtag._drv_mtag._drv_tx_status
#define drv_flowid		builtin_mtag._drv_mtag._drv_flowid
};

/*
 * Protocol specific mbuf tag (at most one protocol metadata per mbuf).
 *
 * Care must be taken to ensure that they are mutually exclusive, e.g.
 * IPSec policy ID implies no TCP segment offload (which is fine given
 * that the former is used on the virtual ipsec interface that does
 * not advertise the TSO capability.)
 */
struct proto_mtag_ {
	union {
		struct tcp_mtag	tcp;		/* TCP specific */
	} __pr_u;
};

/*
 * NECP specific mbuf tag.
 */
struct necp_mtag_ {
	u_int32_t	necp_policy_id;
	u_int32_t	necp_last_interface_index;
	u_int32_t	necp_route_rule_id;
	u_int32_t	necp_app_id;
};

union builtin_mtag {
	struct {
		struct proto_mtag_ _proto_mtag;	/* built-in protocol-specific tag */
		struct pf_mtag	_pf_mtag;	/* built-in PF tag */
		struct necp_mtag_ _necp_mtag; /* built-in NECP tag */
	} _net_mtag;
	struct driver_mtag_ _drv_mtag;
#define necp_mtag builtin_mtag._net_mtag._necp_mtag
#define proto_mtag builtin_mtag._net_mtag._proto_mtag
#define driver_mtag builtin_mtag._drv_mtag
};

/*
 * Record/packet header in first mbuf of chain; valid only if M_PKTHDR set.
 */
struct pkthdr {
	uint64_t rcvif_p;		/* rcv interface */
	/* variables for ip and tcp reassembly */
	uint64_t	pkt_hdr_p;		/* pointer to packet header */
	int32_t	len;			/* total packet length */
	/* variables for hardware checksum */
	/* Note: csum_flags is used for hardware checksum and VLAN */
	u_int32_t csum_flags;		/* flags regarding checksum */
	union {
		struct {
			u_int16_t val;	 /* checksum value */
			u_int16_t start; /* checksum start offset */
		} _csum_rx;
#define	csum_rx_val	_csum_rx.val
#define	csum_rx_start	_csum_rx.start
		struct {
			u_int16_t start; /* checksum start offset */
			u_int16_t stuff; /* checksum stuff offset */
		} _csum_tx;
#define	csum_tx_start	_csum_tx.start
#define	csum_tx_stuff	_csum_tx.stuff
		u_int32_t csum_data;	/* data field used by csum routines */
	};
	u_int16_t vlan_tag;		/* VLAN tag, host byte order */
	/*
	 * Packet classifier info
	 *
	 * PKTF_FLOW_ID set means valid flow ID.  A non-zero flow ID value
	 * means the packet has been classified by one of the flow sources.
	 * It is also a prerequisite for flow control advisory, which is
	 * enabled by additionally setting PKTF_FLOW_ADV.
	 *
	 * The protocol value is a best-effort representation of the payload.
	 * It is opportunistically updated and used only for optimization.
	 * It is not a substitute for parsing the protocol header(s); use it
	 * only as a hint.
	 *
	 * If PKTF_IFAINFO is set, pkt_ifainfo contains one or both of the
	 * indices of interfaces which own the source and/or destination
	 * addresses of the packet.  For the local/loopback case (PKTF_LOOP),
	 * both should be valid, and thus allows for the receiving end to
	 * quickly determine the actual interfaces used by the the addresses;
	 * they may not necessarily be the same or refer to the loopback
	 * interface.  Otherwise, in the non-local/loopback case, the indices
	 * are opportunistically set, and because of that only one may be set
	 * (0 means the index has not been determined.)  In addition, the
	 * interface address flags are also recorded.  This allows us to avoid
	 * storing the corresponding {in,in6}_ifaddr in an mbuf tag.  Ideally
	 * this would be a superset of {ia,ia6}_flags, but the namespaces are
	 * overlapping at present, so we'll need a new set of values in future
	 * to achieve this.  For now, we will just rely on the address family
	 * related code paths examining this mbuf to interpret the flags.
	 */
	u_int8_t pkt_proto;		/* IPPROTO value */
	u_int8_t pkt_flowsrc;		/* FLOWSRC values */
	u_int32_t pkt_flowid;		/* flow ID */
	u_int32_t pkt_flags;		/* PKTF flags (see below) */
	u_int32_t pkt_svc;		/* MM_SVC value */

	u_int32_t pkt_compl_context;		/* Packet completion context */

	union {
		struct {
			u_int16_t src;		/* ifindex of src addr i/f */
			u_int16_t src_flags;	/* src PKT_IFAIFF flags */
			u_int16_t dst;		/* ifindex of dst addr i/f */
			u_int16_t dst_flags;	/* dst PKT_IFAIFF flags */
		} _pkt_iaif;
#define	src_ifindex	_pkt_iaif.src
#define	src_iff		_pkt_iaif.src_flags
#define	dst_ifindex	_pkt_iaif.dst
#define	dst_iff		_pkt_iaif.dst_flags
		u_int64_t pkt_ifainfo;	/* data field used by ifainfo */
		struct {
			u_int32_t if_data; /* bytes in interface queue */
			u_int32_t sndbuf_data; /* bytes in socket buffer */
		} _pkt_bsr;	/* Buffer status report used by cellular interface */
#define	bufstatus_if	_pkt_bsr.if_data
#define	bufstatus_sndbuf	_pkt_bsr.sndbuf_data
	};
	u_int64_t pkt_timestamp;	/* enqueue time */

	/*
	 * Tags (external and built-in)
	 */
	SLIST_HEAD(packet_tags, m_tag) tags; /* list of external tags */
	union builtin_mtag builtin_mtag;
	/*
	 * Module private scratch space (32-bit aligned), currently 16-bytes
	 * large. Anything stored here is not guaranteed to survive across
	 * modules.  The AQM layer (outbound) uses all 16-bytes for both
	 * packet scheduling and flow advisory information.
	 */
	struct {
		union {
			u_int8_t	__mpriv8[16];
			u_int16_t	__mpriv16[8];
			struct {
				union {
					u_int8_t	__val8[4];
					u_int16_t	__val16[2];
					u_int32_t	__val32;
				} __mpriv32_u;
			}		__mpriv32[4];
			u_int64_t	__mpriv64[2];
		} __mpriv_u;
	} pkt_mpriv __attribute__((aligned(4)));
#define	pkt_mpriv_hash	pkt_mpriv.__mpriv_u.__mpriv32[0].__mpriv32_u.__val32
#define	pkt_mpriv_flags	pkt_mpriv.__mpriv_u.__mpriv32[1].__mpriv32_u.__val32
#define	pkt_mpriv_srcid	pkt_mpriv.__mpriv_u.__mpriv32[2].__mpriv32_u.__val32
#define	pkt_mpriv_fidx	pkt_mpriv.__mpriv_u.__mpriv32[3].__mpriv32_u.__val32

	u_int32_t redzone;		/* red zone */
	u_int32_t pkt_compl_callbacks;	/* Packet completion callbacks */
};

/*
 * Description of external storage mapped into mbuf, valid only if M_EXT set.
 */
typedef uint64_t m_ext_free_func_t;
struct m_ext {
	MM_caddr_t	ext_buf;		/* start of buffer */
	m_ext_free_func_t ext_free;	/* free routine if not the usual */
	u_int	ext_size;		/* size of buffer, for ext_free */
	MM_caddr_t	ext_arg;		/* additional ext_free argument */
	struct ext_ref {
		uint64_t paired_p;
		u_int16_t minref;
		u_int16_t refcnt;
		u_int16_t prefcnt;
		u_int16_t flags;
		u_int32_t priv;
		uintptr_t ext_token;
	} *ext_refflags;
};

/*
 * From bsd/i386/params.h
 */

/*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MMS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
 */
#define	MSIZESHIFT	8			/* 256 */
#define	MSIZE		(1 << MSIZESHIFT)	/* size of an mbuf */
#define	MCLSHIFT	11			/* 2048 */
#define	MCLBYTES	(1 << MCLSHIFT)		/* size of an mbuf cluster */
#define	MBIGCLSHIFT	12			/* 4096 */
#define	MBIGCLBYTES	(1 << MBIGCLSHIFT)	/* size of a big cluster */
#define	M16KCLSHIFT	14			/* 16384 */
#define	M16KCLBYTES	(1 << M16KCLSHIFT)	/* size of a jumbo cluster */


/*
 * The following _MLEN and _MHLEN macros are private to xnu.  Private code
 * that are outside of xnu must use the mbuf_get_{mlen,mhlen} routines since
 * the sizes of the structures are dependent upon specific xnu configs.
 */
#define	_MLEN		(MSIZE - sizeof(struct m_hdr))	/* normal data len */
#define	_MHLEN		(_MLEN - sizeof(struct pkthdr))	/* data len w/pkthdr */

/*
 * The mbuf object
 */
struct mbuf {
	struct m_hdr m_hdr;
	union {
		struct {
			struct pkthdr MH_pkthdr;	/* M_PKTHDR set */
			union {
				struct m_ext MH_ext;	/* M_EXT set */
				char	MH_databuf[_MHLEN];
			} MH_dat;
		} MH;
		char	M_databuf[_MLEN];		/* !M_PKTHDR, !M_EXT */
	} M_dat;
};

/* MM is MacOS Mbuf */
#define MM_NEXT		m_hdr.mh_next
#define MM_NEXTPKT	m_hdr.mh_nextpkt
#define MM_DATA		m_hdr.mh_data
#define MM_LEN		m_hdr.mh_len
#define MM_TYPE		m_hdr.mh_type
#define MM_EXT		M_dat.MH.MH_dat.MH_ext

/* mbuf flags (private) */
#define	M_EXT		0x0001	/* has associated external storage */
#define	M_PKTHDR	0x0002	/* start of record */
#define	M_EOR		0x0004	/* end of record */
#define	M_PROTO1	0x0008	/* protocol-specific */
#define	M_PROTO2	0x0010	/* protocol-specific */
#define	M_PROTO3	0x0020	/* protocol-specific */
#define	M_LOOP		0x0040	/* packet is looped back (also see PKTF_LOOP) */
#define	M_PROTO5	0x0080	/* protocol-specific */

/* mbuf pkthdr flags, also in m_flags (private) */
#define	M_BCAST		0x0100	/* send/received as link-level broadcast */
#define	M_MCAST		0x0200	/* send/received as link-level multicast */
#define	M_FRAG		0x0400	/* packet is a fragment of a larger packet */
#define	M_FIRSTFRAG	0x0800	/* packet is first fragment */
#define	M_LASTFRAG	0x1000	/* packet is last fragment */
#define	M_PROMISC	0x2000	/* packet is promiscuous (shouldn't go to stack) */
#define	M_HASFCS	0x4000	/* packet has FCS */
#define	M_TAGHDR	0x8000	/* m_tag hdr structure at top of mbuf data */

/* mbuf types */
#define	MT_FREE		0	/* should be on free list */
#define	MT_DATA		1	/* dynamic (data) allocation */
#define	MT_HEADER	2	/* packet header */
#define	MT_SOCKET	3	/* socket structure */
#define	MT_PCB		4	/* protocol control block */
#define	MT_RTABLE	5	/* routing tables */
#define	MT_HTABLE	6	/* IMP host tables */
#define	MT_ATABLE	7	/* address resolution tables */
#define	MT_SONAME	8	/* socket name */
#define	MT_SOOPTS	10	/* socket options */
#define	MT_FTABLE	11	/* fragment reassembly header */
#define	MT_RIGHTS	12	/* access rights */
#define	MT_IFADDR	13	/* interface address */
#define	MT_CONTROL	14	/* extra-data protocol message */
#define	MT_OOBDATA	15	/* expedited data  */
#define	MT_TAG		16	/* volatile metadata associated to pkts */
#define	MT_MAX		32	/* enough? */

#endif
